Key;Study Number;Title;Item Type;Publication Year;Author;Publication Title;ISBN;ISSN;DOI;Url;Abstract Note;Search Query;;;;;;;;;;;;;
F4A4R3UK;S1;Experience with performing architecture tradeoff analysis;conferencePaper;1999;"Kazman, R.; Barbacci, M.; Klein, M.; Jeromy Carriere, S.; Woods, S.G.";Proceedings of the 1999 International Conference on Software Engineering (IEEE Cat. No.99CB37002);;;10.1145/302405.302452;doi.org/10.1145/302405.302452;Software architectures, like complex designs in any field, embody tradeoffs made by the designers. However, these tradeoffs are not always made explicitly by the designers and they may not understand the impacts of their decisions. This paper describes the use of a scenario-based and model-based analysis technique for software architectures-called ATAM-that not only analyzes a software architecture with respect to multiple quality attributes, but explicitly considers the tradeoffs inherent in the design. This is a method aimed at illuminating risks in the architecture through the identification of attribute trends, rather than at precise characterizations of measurable quality attribute values. In this paper, the operationalization of ATAM is illustrated via a specific example in which we analyzed a U.S. Army system for battlefield management.;SQ1;;;;;;;;;;;;;
TL5QJ6WC;S2;Software architecture analysis based on statechart semantics;conferencePaper;2000;"Dias, M.S.; Vieira, M.E.R.";Tenth International Workshop on Software Specification and Design. IWSSD-10 2000;;;10.1109/IWSSD.2000.891134;doi.org/10.1109/IWSSD.2000.891134;High assurance architecture-based and component-based software development relies fundamentally on the quality of the components of which a system is composed and their configuration. Analysis over those components and their integration as a system plays a key role in the software development process. This paper describes an approach to develop and assess architecture and component-based systems based on specifying software architecture augmented by statecharts representing component behavioral specifications. The approach is applied for the C2 style and associated ADL and is supported within a quality-focussed environment, called Argus-I, which assists specification-based analysis and testing at both the component and architecture levels.;SQ1;;;;;;;;;;;;;
7K4LVCKE;S3;A methodology for architectural-level risk assessment using dynamic metrics;conferencePaper;2000;"Yacoub, S.M.; Ammar, H.H.; Robinson, T.";Proceedings 11th International Symposium on Software Reliability Engineering. ISSRE 2000;;;10.1109/ISSRE.2000.885873;doi.org/10.1109/ISSRE.2000.885873;Risk assessment is an essential process of every software risk management plan. Several risk assessment techniques are based on the subjective judgement of domain experts. Subjective risk assessment techniques are human-intensive and error-prone. Risk assessment should be based on product attributes that we can quantitatively measure using product metrics. This paper presents a methodology for risk assessment at the early stages of the development lifecycle, namely the architecture level. We describe a heuristic risk assessment methodology that is based on dynamic metrics obtained from UML specifications. The methodology uses dynamic complexity and dynamic coupling metrics to define complexity factors for the architecture elements (components and connectors). Severity analysis is performed using FMEA (failure mode and effect analysis), as applied to architecture simulation models. We combine severity and complexity factors to develop heuristic risk factors for the architecture components and connectors. Based on component dependency graphs that were developed earlier for reliability analysis, and using analysis scenarios, we develop a risk assessment model and a risk analysis algorithm that aggregates the risk factors of components and connectors to the architectural level. We show how to analyze the overall risk factor of the architecture as the function of the risk factors of its constituting components and connectors. A case study of a pacemaker is used to illustrate the application of the methodology.;SQ1;;;;;;;;;;;;;
5UAEY7ZI;S4;An Empirically-Based Process for Software Architecture Evaluation;journalArticle;2003;"Lindvall, Mikael; Tvedt, Roseanne Tesoriero; Costa, Patricia";Empirical Software Engineering;;1573-7616;10.1023/A:1021772917036;https://doi.org/10.1023/A:1021772917036;Software systems undergo constant change causing the architecture of the system to degenerate over time. Reversing system degeneration takes extra effort and delays the release of the next version. Improved architecture is intangible and does not translate into visible user features that can be marketed. Due to a lack of representative metrics, technical staff has problems arguing that stopping degeneration is indeed necessary and that the effort will result in an improved architecture that will pay off. We believe that architectural metrics would give technical staff better tools to demonstrate that the architecture has improved. This paper defines and uses a set of architectural metrics and outlines a process for analyzing architecture to support such an argument. The paper reports on a case study from a project where we restructured the architecture of an existing client-server system written in Java while adding new functionality. The modules of the existing version of the system were “library-oriented” and had a disorganized communication structure. The new architecture is based on components and utilizes the mediator design pattern. The goal of the study is to evaluate the new architecture from a maintainability perspective. The paper describes our evaluation process, the metrics used, and provides some preliminary results. The architectural evaluation shows that the components of the system are only loosely coupled to each other and that an architectural improvement has occurred from a maintenance perspective. The process used to evaluate the architecture is general and can be reused in other contexts.;SQ1;;;;;;;;;;;;;
UY85SCZ4;S5;Architecture-level modifiability analysis (ALMA);journalArticle;2004;"Bengtsson, PerOlof; Lassing, Nico; Bosch, Jan; van Vliet, Hans";Journal of Systems and Software;;0164-1212;;;;SQ1;;;;;;;;;;;;;
VQY4E58J;S6;A scenario-driven approach for value, risk, and cost analysis in system architecting for innovation;conferencePaper;2004;"Ionita, Mugurel T; America, Pierre; Hammer, Dieter K; Obbink, Henk; Trienekens, Jos JM";;0-7695-2172-X;;10.1109/WICSA.2004.1310709;www.doi.org/10.1109/WICSA.2004.1310709;We present a quantitative method for scenario-driven value, risk, and cost analysis when proposing new system architectures for innovation projects. The method helps to articulate the relative benefits and/or disadvantages of the proposed set of scenarios in the early architecting phases of a new system. It provides the arguments on which to base an informed decision to select the final architectural scenarios for further consideration in the design. In this paper we present a case study in which we applied the proposed method.;SQ1;;;;;;;;;;;;;
B7SGDU4G;S7;ASAAM: aspectual software architecture analysis method;conferencePaper;2004;Tekinerdogan, B.;Proceedings. Fourth Working IEEE/IFIP Conference on Software Architecture (WICSA 2004);;;10.1109/WICSA.2004.1310685;;Software architecture analysis methods aim to predict the quality of a system before it has been developed. In general, the quality of the architecture is validated by analyzing the impact of predefined scenarios on architectural components. Hereby, it is implicitly assumed that an appropriate refactoring of the architecture design can help in coping with critical scenarios and mending the architecture. This paper shows that there are also concerns at the architecture design level which inherently crosscut multiple architectural components, which cannot be localized in one architectural component and which, as such, can not be easily managed by using conventional abstraction mechanisms. We propose the aspectual software architecture analysis method (ASAAM) to explicitly identify and specify these architectural aspects and make them transparent early in the software development life cycle. ASAAM introduces a set of heuristic rules that help to derive architectural aspects and the corresponding tangled architectural components from scenarios. The approach is illustrated for architectural aspect identification in the architecture design of a window management system.;SQ1;;;;;;;;;;;;;
GVDNVQYX;S8;Knowledge centered assessment pattern: an effective tool for assessing safety concerns in software architecture;journalArticle;2004;"Khajenoori, Soheil; Prem, Lorenz; Stevens, Karen; Keng, Ban Seng; Kameli, Nader";Journal of Systems and Software;;0164-1212;10.1016/j.jss.2003.09.018;https://www.sciencedirect.com/science/article/pii/S0164121203002619;In software-based systems, the notion of software failure is magnified if the software in question is a component of a safety critical system. Hence, to ensure a required level of safety, the product must undergo expensive rigorous testing and verification/validation activities. To minimize the cost of quality (COQ) associated with the development of safety critical systems, it becomes imperative that the assessment of intermediate artifacts (e.g., requirement, design documents or models) is done efficiently and effectively to maximize early defect detection and/or defect prevention. However, as a human-centered process, the assessment of software architecture for safety critical systems relies heavily on the experience and knowledge of the assessment team to ensure that the proposed architecture is consistent with the software functional and safety requirements. The knowledge centered assessment pattern (KCAP) acts as effective tool to assist assessment teams by providing key information on what architectural elements should be assessed, why they should to be assessed, and how they should be assessed. Furthermore, the use of KCAP highlights cases where the software architecture has been properly, over, under, or incoherently engineered.;SQ1;;;;;;;;;;;;;
62L6GKJM;S9;Evaluating an embedded software reference architecture-industrial experience report;conferencePaper;2005;"Graaf, Bas; Van Dijk, Hylke; Van Deursen, Arie";;0-7695-2304-8;;10.1109/CSMR.2005.28;https://ieeexplore.ieee.org/document/1402153;In this paper, we discuss experiences gained during evaluation of the maintainability of a reference architecture in use at Oce, one of the world's leading copier manufacturers. The evaluation is conducted using an approach based on SEI's software architecture analysis method (SAAM). The paper proposes a variant of SAAM that helps to reduce the organisational impact of architecture evaluations. Second, we analyse the implications of evaluating reference architectures as opposed to single-product architectures. Furthermore, we share our experience of conducting the evaluation, draw lessons for practitioners, and propose new research topics.;SQ1;;;;;;;;;;;;;
T8KHF6JQ;S10;Case studies on analyzing software architectures for usability;conferencePaper;2005;"Folmer, E.; Bosch, J.";31st EUROMICRO Conference on Software Engineering and Advanced Applications;;;10.1109/EUROMICRO.2005.17;;Studies of software engineering projects reveal that a large number of usability related change requests are made after its deployment. Fixing certain usability problems during the later stages of development has proven to be costly, since some of these changes require changes to the software architecture i.e. this often requires large parts of code to be completely rewritten. Explicit evaluation of usability during architectural design may reduce the risk of building a system that fails to meet its usability requirements and may prevent high costs incurring adaptive maintenance activities once the system has been implemented. In this paper, we demonstrate the use of a scenario based architecture analysis technique for usability we developed, at two case studies.;SQ1;;;;;;;;;;;;;
FFTJE5D4;S11;Information System Architecture Evaluation: From Software to Enterprise Level Approaches;conferencePaper;2005;"Vasconcelos, André; Sousa, Pedro; Tribolet, José";Proceedings, 12th European Conference On Information Technology Evaluation (ECITE 2005), Turku, Finland;;;;https://www.researchgate.net/profile/Jose-Tribolet/publication/228967139_Information_System_Architecture_Evaluation_From_Software_to_Enterprise_Level_Approaches/links/0fcfd509063247a186000000/Information-System-Architecture-Evaluation-From-Software-to-Enterprise-Level-Approaches.pdf;In order to ensure that technology supports business needs and that IT investments deliver the desired value, it is fundamental to define an Information System Architecture (ISA) and measure its accurateness to the business model and existing technologies. Thus, in this paper we are concern on evaluating ISA by measuring its qualities (relevant at enterprise level). Since software architecture (SA) is part of the information system architecture and the evaluation topic is a quite mature issue on the software engineering domain, we enumerate and classify several software evaluation approaches in order to consider its applicability to ISA evaluation. Therefore, in this paper, we present and classify the most significant software evaluation issues, namely: software qualities, software evaluation approaches, and software metrics. Our preliminary findings indicate that: the quality attributes relevant for SA evaluation are generally applicable for ISA evaluation, the SA evaluation approaches are also useful for ISA evaluation, and the SA metrics are not applicable to ISA evaluation. In this paper we propose a set of metrics for ISA evaluation, considering the most experienced and tested software engineering metrics. We apply the ISA evaluation approach, qualities and metrics to a health-care project case study.;SQ1;;;;;;;;;;;;;
EP9YRZSI;S12;Software Architecture Analysis of Usability;conferencePaper;2004;"Folmer, Eelke; van Gurp, Jilles; Bosch, Jan";;;;10.1007/11431879_3;doi.org/10.1007/11431879_3;;SQ1;;;;;;;;;;;;;
APSXRQLH;S13;Static evaluation of software architectures;conferencePaper;2006;"Knodel, Jens; Lindvall, Mikael; Muthig, Dirk; Naab, Matthias";;0-7695-2536-9;;10.1109/CSMR.2006.53;https://ieeexplore.ieee.org/document/1602379;The software architecture is one of the most crucial artifacts within the lifecycle of a software system. Decisions made at the architectural level directly enable, facilitate, hamper, or interfere with the achievement of business goals, functional and quality requirements. Architecture evaluations play an important role in the development and evolution of software systems since they determine how adequate the architecture is for its intended usage. This paper summarizes our practical experience with using architecture evaluations and gives an overview on when and how static architecture evaluations contribute to architecture development. We identify ten distinct purposes and needs for static architecture evaluations and illustrate them using a set of industrial and academic case studies. In particular, we show how subsequent steps in architecture development are influenced by the results from architecture evaluations;SQ1;;;;;;;;;;;;;
HFM296PE;S14;Applying dynamic change impact analysis in component-based architecture design;conferencePaper;2006;"Feng, Tie; Maletic, Jonathan I";;0-7695-2611-X;;10.1109/SNPD-SAWN.2006.21;https://ieeexplore.ieee.org/abstract/document/1640665;Change impact analysis plays an important role in maintenance and evolution of component-based software architecture. Viewing component replacement as a change to composition-based software architecture, this paper proposes a component interaction trace based approach to support dynamic change impact analysis at software architecture level. Given an architectural change, our approach determines the architecture elements causing the change and impacted by the change. Firstly, component-based software architecture and component interaction trace are defined. An algorithm for generating component interaction trace from static structure model of software architecture and UML sequence diagram is provided. Secondly, the taxonomy of changes on composition-based software architecture is presented, according to which a set of impact rules are suggested to determine the transfer of the changes in component and among components. Thirdly, by performing slicing on component interaction traces according to impact rules, the impact analysis results are obtained. Finally, the architecture design of SOCIAT, a tool supporting our approach, is developed and explained.;SQ1;;;;;;;;;;;;;
CYVAT8GX;S15;The essential components of software architecture design and analysis;journalArticle;2006;"Kazman, Rick; Bass, Len; Klein, Mark";Journal of Systems and Software;;0164-1212;10.1016/j.jss.2006.05.001;https://www.sciencedirect.com/science/article/pii/S0164121206001439;Architecture analysis and design methods such as ATAM, QAW, ADD and CBAM have enjoyed modest success and are being adopted by many companies as part of their standard software development processes. They are used in the lifecycle, as a means of understanding business goals and stakeholders concerns, mapping these onto an architectural representation, and assessing the risks associated with this mapping. These methods have evolved a set of shared component techniques. In this paper we show how these techniques can be combined in countless ways to create needs-specific methods in an agile way. We demonstrate the generality of these techniques by describing a new architecture improvement method called APTIA (Analytic Principles and Tools for the Improvement of Architectures). APTIA almost entirely reuses pre-existing techniques but in a new combination, with new goals and results. We exemplify APTIA’s use in improving the architecture of a commercial information system.;SQ1;;;;;;;;;;;;;
M52P29SR;S16;Tool support to model-based quality analysis of software architecture;conferencePaper;2006;"Zhang, Qian; Wu, Jian; Zhu, Hong";30th Annual International Computer Software and Applications Conference (COMPSAC'06);;;10.1109/COMPSAC.2006.82;https://ieeexplore.ieee.org/document/4020069?denied=;;SQ1;;;;;;;;;;;;;
5GTN88W8;S17;MEMS: A Method for Evaluating Middleware Architectures;conferencePaper;2006;"Liu, Yan; Gorton, Ian; Bass, Len; Hoang, Cuong; Abanmi, Suhail";Quality of Software Architectures;978-3-540-48820-0;;10.1007/11921998_6;;Middleware architectures play a crucial role in determining the overall quality of many distributed applications. Systematic evaluation methods for middleware architectures are therefore important to thoroughly assess the impact of design decisions on quality goals. This paper presents MEMS, a scenario-based evaluation approach. MEMS provides a principled way of evaluating middleware architectures by leveraging generic qualitative and quantitative evaluation techniques such as prototyping, testing, rating, and analysis. It measures middleware architectures by rating multiple quality attributes, and the outputs aid the determination of the suitability of alternative middleware architectures to meet an application’s quality goals. MEMS also benefits middleware development by uncovering potential problems at early stage, making it cheaper and quicker to fix design problems. The paper describes a case study to evaluate the security architecture of grid middleware architectures for managing secure conversations and access control. The results demonstrate the practical utility of MEMS for evaluating middleware architectures for multiple quality attributes.;SQ1;;;;;;;;;;;;;
GGREHCWT;S18;On the Modularity of Software Architectures: A Concern-Driven Measurement Framework;conferencePaper;2007;"Sant’Anna, Cláudio; Figueiredo, Eduardo; Garcia, Alessandro; Lucena, Carlos J. P.";Software Architecture;978-3-540-75132-8;;10.1007/978-3-540-75132-8_17;;Much of the complexity of software architecture design is derived from the inadequate modularization of key broadly-scoped concerns, such as exception handling, distribution, and persistence. However, conventional architecture metrics are not sensitive to the driving architectural concerns, thereby leading a number of false positives and false negatives in the design assessment process. Therefore, there is a need for assessment techniques that support a more effective identification of early design modularity anomalies relative to crosscutting concerns. In this context, this paper proposes a concern-driven measurement framework for assessing architecture modularity. It encompasses a mechanism for documenting architectural concerns, and a suite of concern-oriented architecture metrics. We evaluated the usefulness of the proposed framework while comparing the modularity of architecture design alternatives in three different case studies.;SQ1;;;;;;;;;;;;;
QVFCFCN4;S19;Beyond ATAM: Architecture Analysis in the Development of Large Scale Software Systems;conferencePaper;2007;Zalewski, Andrzej;Software Architecture;978-3-540-75132-8;;10.1007/978-3-540-75132-8_8;;"Large scale software developments require substantial investment and are exposed to high level of risk. Architectural decisions taken at early stages of the development can substantially influence the entire level of technical risk. In this paper architectural decisions are divided into two basic groups: early – top level system organization decision establishing system organization patterns (the notion introduced in this paper) and detailed ones. However as it was shown on notable examples of large scale developments carried out in recent ten years in Poland, wrong decisions concerning system organization pattern can trigger severe risks that can lead to the development crisis. These risks are frequently connected with the complexity explosion syndrome – sudden, undetected growth of design complexity that exceeds the capabiblity of the development team and time budget. To manage these risks properly appropriate architecture analysis method has been introduced. On the contrary to the traditional scenario-based architecture analysis methods, like ATAM, it was based on GQM approach. A complete assessement framework have been defined comprising three goals: complexity control, organizational adequacy and satisfactory perforormance and reliability; a set of questions related to these goals, as well as metrics for the qualities expressed by these questions. The conclusion contains ex post analysis of exemplary large scale systems showing that the proposed framework provides adequate assessement of design risk. It has also been indicated that the critical risks identified during the evalution of the system organization pattern should be carefully managed.";SQ1;;;;;;;;;;;;;
MKKEPZTU;S20;A holistic architecture assessment method for software product lines;journalArticle;2007;"Olumofin, Femi G.; Mišić, Vojislav B.";Information and Software Technology;;0950-5849;10.1016/j.infsof.2006.05.003;https://www.sciencedirect.com/science/article/pii/S0950584906000747;The success of architecture-centric development of software product lines is critically dependent upon the availability of suitable architecture assessment methods. While a number of architecture assessment methods are available and some of them have been widely used in the process of evaluating single product architectures, none of them is equipped to deal with the main challenges of product line development. In this paper we present an adaptation of the Architecture Tradeoff Analysis Method (ATAM) for the task of assessing product line architectures. The new method, labeled Holistic Product Line Architecture Assessment (HoPLAA), uses a holistic approach that focuses on risks and quality attribute tradeoffs – not only for the common product line architecture, but for the individual product architectures as well. In addition, it prescribes a qualitative analytical treatment of variation points using scenarios. The use of the new method is illustrated through a case study.;SQ1;;;;;;;;;;;;;
5IH2BRR8;S21;Extending Failure Modes and Effects Analysis Approach for Reliability Analysis at the Software Architecture Design Level;bookSection;2007;"Sozer, Hasan; Tekinerdogan, Bedir; Aksit, Mehmet";Architecting Dependable Systems IV;978-3-540-74033-9 978-3-540-74035-3;;;http://link.springer.com/10.1007/978-3-540-74035-3_18;Several reliability engineering approaches have been proposed to identify and recover from failures. A well-known and mature approach is the Failure Mode and Effect Analysis (FMEA) method that is usually utilized together with Fault Tree Analysis (FTA) to analyze and diagnose the causes of failures. Unfortunately, both approaches seem to have primarily focused on failures of hardware components and less on software components. Moreover, for utilizing FMEA and FTA very often an existing implementation of the system is required to perform the reliability analysis. We propose extensions to FMEA and FTA to utilize them for the reliability analysis of software at the architecture design level. We present the software architecture reliability analysis approach (SARAH) that incorporates the extended FMEA and FTA. The approach is illustrated using an industrial case for analyzing reliability of the software architecture of a Digital TV.;SQ1;;;;;;;;;;;;;
7ZX9PAT3;S22;Towards a method for the evaluation of reference architectures: Experiences from a case;conferencePaper;2008;"Angelov, Samuil; Trienekens, Jos JM; Grefen, Paul";;978-3-540-88029-5;;;https://link.springer.com/chapter/10.1007/978-3-540-88030-1_17;Reference architectures provide major guidelines for the structure of a class of information systems. Because of their fundamental role, reference architectures have to be of high quality. Before accepting a reference architecture, it has to go through a rigorous evaluation process. A number of methods exist for the evaluation of software architectures. In this paper, we analyze the main differences between concrete software architectures and reference architectures. We discuss the effects of these differences on the evaluation of reference architectures and show that existing methods cannot be directly applied for the evaluation of reference architectures. For the evaluation of a reference architecture for e-contracting systems, we used the Architecture Tradeoff Analysis Method with a number of adaptations and extensions. We present our approach and share our experiences from this evaluation process. Based on the analysis and our experiences gained, we present our vision for a method for the evaluation of reference architectures.;SQ1;;;;;;;;;;;;;
ZX7SSBDM;S23;Using dependency model to support software architecture evolution;conferencePaper;2008;"Breivold, Hongyu Pei; Crnkovic, Ivica; Land, Rikard; Larsson, Stig";;1-4244-2776-2;;10.1109/ASEW.2008.4686324;https://ieeexplore.ieee.org/document/4686324;Evolution of software systems is characterized by inevitable changes of software and increasing software complexity, which in turn may lead to huge maintenance and development costs. For long-lived systems, there is a need to address and maintain evolvability (i.e. a systempsilas ability to easily accommodate changes) during the entire lifecycle. As designing software for ease of extension and contraction depends on how well the software structure is organized, this paper explores the relationships between evolvability, modularity and inter-module dependency. Through a case study of an industrial power control and protection system, we describe our work in managing its software architecture evolution, guided by the dependency analysis at the architectural level. The paper includes also the main analysis results, our experiences and reflections during the dependency analysis process in the case study.;SQ1;;;;;;;;;;;;;
JARG45JQ;S24;Extending ATAM to assess product line architecture;conferencePaper;2008;"Kim, Taeho; Ko, In-young; Kang, Sung-won; Lee, Dan-hyung";;1-4244-2357-0;;10.1109/CIT.2008.4594775;https://ieeexplore.ieee.org/document/4594775;Software architecture is a core asset for any organization that develops software-intensive systems. Unsuitable architecture can precipitate disaster because the architecture determines the structure of the project. To prevent this, software architecture must be evaluated. The current evaluation methods, however, focus on single product architecture, and not product line architectures and they hardly consider the characteristics of the product lines, such as the variation points. This paper describes the extension of a scenario-based analysis technique for software product architecture-called EATAM, which not only analyzes the variation points of the quality attribute using feature modeling but also creates variability scenarios for the derivation of the variation points using the extended PLUC tag approach. This is a method that aims to consider the tradeoffs in the variability scenarios of the software product family architecture. The method has been validated through a case study involving microwave oven software product line in the appliance domain.;SQ1;;;;;;;;;;;;;
6Q9RV3P7;S25;Comprehensive Architecture Evaluation and Management in Large Software-Systems;conferencePaper;2008;"Salger, Frank; Bennicke, Marcel; Engels, Gregor; Lewerentz, Claus";Quality of Software Architectures. Models and Architectures;978-3-540-87879-7;;10.1007/978-3-540-87879-7_13;;The architecture of a software system is both a success and a failure factor. Taking the wrong architectural decisions may break a project, since such errors are often systematic and affect cross-cutting aspects of the system to be built. Moreover, software projects get more and more challenging due to the rising complexity and dynamics of business processes, large team size and distributed development. As the software architecture is the common platform for many project activities, it constitutes a critical success factor. Thus, a comprehensive method for evaluating a software architecture and propagating important properties of it downstream to code is needed. At sd&m, we designed a comprehensive architecture evaluation and management framework in order to satisfy these needs. In this paper, we derive a list of requirements, such a framework should fulfill. We then present the components of our architecture evaluation method and demonstrate, how it fulfills these requirements.;SQ1;;;;;;;;;;;;;
N7WL7J7Z;S26;Some Metrics for Accessing Quality of Product Line Architecture;conferencePaper;2008;"Zhang, Tao; Deng, Lei; Wu, Jian; Zhou, Qiaoming; Ma, Chunyan";2008 International Conference on Computer Science and Software Engineering;;;10.1109/CSSE.2008.500;;Product line architecture is the most important core asset of software product line. vADL, a product line architecture description languages, can be used for specifying product line architecture, and also provide enough information for measuring quality of product line architecture. In this paper, some new metrics are provided to assess similarity, variability, reusability, and complexity of product line architecture. The main feature of our approach is to assess the quality of product line architecture by analyzing its formal vADL specification, and therefore the process of metric computation can be automated completely.;SQ1;;;;;;;;;;;;;
9H2PUU6D;S27;Experiences with Software Architecture Analysis of Usability;journalArticle;2008;"Folmer, Eelke; Bosch, Jan";International Journal of Information Technology and Web Engineering (IJITWE);;1554-1045;10.4018/jitwe.2008100101;https://www.igi-global.com/article/experiences-software-architecture-analysis-usability/www.igi-global.com/article/experiences-software-architecture-analysis-usability/2648;Software engineers and human computer interaction engineers have come to the understanding that usability is not something that can be “added” to a software product during late stage, since to a certain extent it is determined and restricted by architecture design. Cost effectively developing a usab...;SQ1;;;;;;;;;;;;;
QEGUSDH4;S28;Analyzing Software Evolvability of an Industrial Automation Control System: A Case Study;conferencePaper;2008;"Breivold, Hongyu Pei; Crnkovic, Ivica; Land, Rikard; Larsson, Magnus";2008 The Third International Conference on Software Engineering Advances;;;10.1109/ICSEA.2008.16;;"Evolution of software systems is characterized by inevitable changes of software and increasing software complexity, which in turn may lead to huge maintenance and development costs. For long-lived systems, there is a need to address evolvability (i.e. a systempsilas ability to easily accommodate changes) explicitly in the requirements and early design phases, and maintain it during the entire lifecycle. This paper describes our work in analyzing and improving the evolvability of an industrial automation control system, and presents (1) evolvability subcharacteristics based on the problems in the case and available literature; (2) a structured method for analyzing evolvability at the architectural level - the ARchitecture Evolvability Analysis (AREA) method. This paper includes also the main analysis results and our observations during the evolvability analysis process in the case study. The evolvability subcharacteristics and the method should be generally applicable, and they are being validated within another domain at the time of writing.";SQ1;;;;;;;;;;;;;
8NZ6FR8S;S29;Adaptability Evaluation at Software Architecture Level;journalArticle;2008;Tarvainen, Pentti;The Open Software Engineering Journal;;1874107X;10.2174/1874107X00802010001;http://benthamopen.com/ABSTRACT/TOSEJ-2-1;Quality of software is one of the major issues in software intensive systems and it is important to analyze it as early as possible. An increasingly important quality attribute of complex software systems is adaptability. Software architecture for adaptive software systems should be flexible enough to allow components to change their behaviors depending upon the environmental and stakeholders' changes and goals of the system. Evaluating adaptability at software architecture level to identify the weaknesses of the architecture and further to improve adaptability of the architecture are very important tasks for software architects today. Our contribution is an Adaptability Evaluation Method (AEM) that defines, before system implementation, how adaptability requirements can be negotiated and mapped to the architecture, how they can be represented in architectural models, and how the architecture can be evaluated and analyzed in order to validate whether or not the requirements are met. AEM fills the gap from requirements engineering to evaluation and provides an approach for adaptability evaluation at the software architecture level. In this paper AEM is described and validated with a real-world wireless environment control system. Furthermore, adaptability aspects, role of quality attributes, and diversity of adaptability definitions at software architecture level are discussed.;SQ1;;;;;;;;;;;;;
8NJTQRLS;S30;Software architecture reliability analysis using failure scenarios;journalArticle;2008;"Tekinerdogan, Bedir; Sozer, Hasan; Aksit, Mehmet";Journal of Systems and Software;;0164-1212;10.1016/j.jss.2007.10.029;https://www.sciencedirect.com/science/article/pii/S0164121207003032;With the increasing size and complexity of software in embedded systems, software has now become a primary threat for the reliability. Several mature conventional reliability engineering techniques exist in literature but traditionally these have primarily addressed failures in hardware components and usually assume the availability of a running system. Software architecture analysis methods aim to analyze the quality of software-intensive system early at the software architecture design level and before a system is implemented. We propose a Software Architecture Reliability Analysis Approach (SARAH) that benefits from mature reliability engineering techniques and scenario-based software architecture analysis to provide an early software reliability analysis at the architecture design level. SARAH defines the notion of failure scenario model that is based on the Failure Modes and Effects Analysis method (FMEA) in the reliability engineering domain. The failure scenario model is applied to represent so-called failure scenarios that are utilized to derive fault tree sets (FTS). Fault tree sets are utilized to provide a severity analysis for the overall software architecture and the individual architectural elements. Despite conventional reliability analysis techniques which prioritize failures based on criteria such as safety concerns, in SARAH failure scenarios are prioritized based on severity from the end-user perspective. SARAH results in a failure analysis report that can be utilized to identify architectural tactics for improving the reliability of the software architecture. The approach is illustrated using an industrial case for analyzing reliability of the software architecture of the next release of a Digital TV.;SQ1;;;;;;;;;;;;;
VSY9UTT5;S31;Using software architecture risk assessment for product line architectures;conferencePaper;2009;"Abdelmoez, WM; Jalali, AH; Shaik, K; Menzies, T; Ammar, HH";;;;;;This paper demonstrates the usage of Software Architecture Risk Assessment (SARA) process and a supporting prototype tool to assess maintainability-based risk for product line architectures. The prototype tool accepts different types of inputs that define the software architecture. It parses these input files and produces quantitative metrics that are used to estimate the required risk factors. The final result of this process is to discern the potentially high risk components in the software system. By manipulating the data acquired from domain expert and measures obtained from Unified Modeling Language (UML) artifacts, SARA can be used at the architecture development phase, at the design phase, or at the implementation phase of the software development process to improve the quality of the software product line.;SQ1;;;;;;;;;;;;;
KWS9DHY2;S32;Towards a Method for Analyzing Architectural Support Levels of Usability;conferencePaper;2009;"Biel, Bettina; Gruhn, Volker";;1-4244-4984-7;;;https://ieeexplore.ieee.org/document/5290818;The user acceptance of a software product especially depends on its usability. Therefore, it is a matter that needs to be addressed early in the software development process. In existing scenario-based software architecture analysis methods that focus on usability, the usage context is not employed to select scenarios used for analysis, although it is known that understanding a specific usage context is important to carefully design for usability. In order to address this, we propose in this position paper the ldquomethod for analyzing architectural support levels of usabilityrdquo, which incorporates a usage context analysis and a simple standards inspection of a user interface prototype. It furthermore provides a knowledge base of standardized analysis scenarios and analysis templates that are derived from general usability requirements and design patterns. By defining architectural support levels (ASL), which are defined based on analysis scenario gradings, the proposed procedure model shall guide evaluators to accomplish a repeatable analysis resulting in a rating of the current design for usability in a traceable way.;SQ1;;;;;;;;;;;;;
YB8DNYPB;S33;A Framework for Supporting the Software Architecture Evaluation Process in Global Software Development;conferencePaper;2009;Babar, Muhammad Ali;2009 Fourth IEEE International Conference on Global Software Engineering;;;10.1109/ICGSE.2009.17;;Software Architecture (SA) evaluation process requires a large number of stakeholders to be collocated for evaluation sessions. Given the increasing trend of using globally distributed software development teams, organizations are likely to be discouraged from introducing disciplined architectural evaluation practices that require stakeholders to be collocated. To address this issue, we propose that SA evaluation can be carried out using suitable groupware systems. In this paper, we present a framework for supporting the SA evaluation process using groupware systems. The framework highlights the changes required in the existing SA evaluation processes. We provide an illustrated example of modeling and mapping the activities of the proposed process on electronic workspaces provided by a groupware system. We have also identified some of the features a groupware system should have to successfully support the process.;SQ1;;;;;;;;;;;;;
EQIQ36K9;S34;Software architecture evaluation methods based on cost benefit analysis and quantitative decision making;journalArticle;2009;"Lee, Jihyun; Kang, Sungwon; Kim, Chang-Ki";Empirical Software Engineering;;1573-7616;10.1007/s10664-008-9094-4;https://doi.org/10.1007/s10664-008-9094-4;Since many parts of the architecture evaluation steps of the Cost Benefit Analysis Method (CBAM) depend on the stakeholders’ empirical knowledge and intuition, it is very important that such an architecture evaluation method be able to faithfully reflect the knowledge of the experts in determining Architectural Strategy (AS). However, because CBAM requires the stakeholders to make a consensus or vote for collecting data for decision making, it is difficult to accurately reflect the stakeholders’ knowledge in the process. In order to overcome this limitation of CBAM, we propose the two new CBAM-based methods for software architecture evaluation, which respectively adopt the Analytic Hierarchy Process (AHP) and the Analytic Network Process (ANP). Since AHP and ANP use pair-wise comparison they are suitable for a cost and benefit analysis technique since its purpose is not to calculate correct values of benefit and cost but to decide AS with highest return on investment. For that, we first define a generic process of CBAM and develop variations from the generic process by applying AHP and ANP to obtain what we call the CBAM+AHP and CBAM+ANP methods. These new methods not only reflect the knowledge of experts more accurately but also reduce misjudgments. A case study comparison of CBAM and the two new methods is conducted using an industry software project. Because the cost benefit analysis process that we present is generic, new cost benefit analysis techniques with capabilities and characteristics different from the three methods we examine here can be derived by adopting various different constituent techniques.;SQ1;;;;;;;;;;;;;
EE3IMJSF;S35;A new AHP-based approach towards Enterprise Architecture quality attribute analysis;conferencePaper;2009;"Razavi Davoudi, Mahsa; Shams Aliee, Fereidoon";2009 Third International Conference on Research Challenges in Information Science;;;10.1109/RCIS.2009.5089297;;Enterprise Architecture (EA) as a discipline with numerous and enterprise-wide models, can support decision making on several enterprise-wide issues. In order to provide such a capability, enterprise architecture models should be amenable to analysis of various utilities and quality attributes. This paper provides a method towards enterprise architecture analysis. This approach is based on Analytical Hierarchy Process (AHP) and considers the situation of the enterprise in giving weight to the different criteria and sub-criteria of each utility. It proposes a quantitative method of measuring quality attribute achievement for each scenario using AHP based on the knowledge and experience of EA experts and domain experts and demonstrates its efficacy by applying it to a case study.;SQ1;;;;;;;;;;;;;
678JGVCR;S36;Lightweight and continuous architectural software quality assurance using the aSQA technique;conferencePaper;2010;"Christensen, Henrik Bærbak; Hansen, Klaus Marius; Lindstrøm, Bo";;;;10.1007/978-3-642-15114-9_11;https://link.springer.com/chapter/10.1007/978-3-642-15114-9_11;In this paper, we present a novel technique for assessing and prioritizing architectural quality in large-scale software development projects. The technique can be applied with relatively little effort by software architects and thus suited for agile development in which quality attributes can be assessed and prioritized, e.g., within each development sprint. We outline the processes and metrics embodied in the technique, and report initial experiences on the benefits and liabilities. In conclusion, the technique is considered valuable and a viable tool, and has benefits in an architectural, technical, context, as well as in a business and people context.;SQ1;;;;;;;;;;;;;
4E3FX7Q3;S37;Cpasa: continuous performance assessment of software architecture;conferencePaper;2010;"Pooley, RJ; Abdullatif, AAL";;1-4244-6538-9;;10.1109/ECBS.2010.16;https://ieeexplore.ieee.org/document/5457784;Software architecture is a very important factor when it comes to performance measurements. A large percentage of projects failing their potential performance characterisation was caused by badly configured architectures. Performance assessment of software architectures proved to be a successful way of preventing this risk. Non-functional requirements verification is still an uncharted area in agile development. CPASA provides a method for assessing the performance requirements using the system architecture as a base for conducting the performance study. In this paper, we introduce the steps in the CPASA method and the technical description of how to deploy this method.;SQ1;;;;;;;;;;;;;
C9A3UZBY;S38;A scenario-based framework for the security evaluation of software architecture;conferencePaper;2010;"Alkussayer, Abdulaziz; Allen, William H";;1-4244-5540-5;;;https://ieeexplore.ieee.org/document/5564015;Software security has become a crucial component of software systems in today's market. However, software security development is still a maturing process. In this paper, we present an approach for assessing software architecture to determine how well it can satisfy intended security requirements. It is important to be able to assess the security of software under development at an early stage (e.g., the design stage). By doing so we are not only reducing the probability that flaws will be introduced and ensuring that stakeholder requirements have been met, but also focusing on a stage where changes will cost just a fraction of what they would cost in later stages (e.g. implementation). This paper reports on the ongoing development of a systematic security evaluation framework that aids in assessing the level of security supported by a given architecture and provides the ability to qualitatively compare multiple architectures with respect to their security support.;SQ1;;;;;;;;;;;;;
BHSD3JKQ;S39;Security risk analysis of software architecture based on AHP;conferencePaper;2011;"Alkussayer, Abdulaziz; Allen, William H";;89-88678-43-5;;;https://ieeexplore.ieee.org/document/6058946;Many organizations and companies around the world are currently facing major security risks that threaten assets and valuable information system resources. Numerous security concerns are caused by the lack of sufficient and effective software security risk evaluation processes. Regardless of the technique used in security attacks, which change rapidly, many of these threats can be avoided. This paper presents an effective model for discovering software security risks at an early stage of the software development cycle and reports on the ongoing development of a security trust metrics of software architecture.;SQ1;;;;;;;;;;;;;
DZE629PI;S40;Security Risk Assessment of Software Architecture;conferencePaper;2011;"HajSaid, Fadi; Hassouneh, Yousef; Ammar, HH";;;;;https://www.academia.edu/21257560/Security_Risk_Assessment_of_Software_Architecture?auto=citations&from=cover_page;Security risk assessment is considered a significant and indispensible process in all phases of software development lifecycles, and most importantly at the early phases. Estimating the security risk should be integrated with the other product developments parts and this will help developers and engineers determine the risky elements in the software system, and reduce the failure consequences in that software. This is done by building models based on the data collected at the early development cycles. These models will help identify the high security risk elements. In this paper, we introduce a new methodology used at the early phases based on the Unified Modeling Language (UML), Attack graph, and other factors. We estimate the probability and severity of security failure for each element in software architecture based on UML, attack graph, data sensitivity analysis, access rights, and reachability matrix. Then risk factors are computed. An e-commerce case study is investigated as an example.;SQ1;;;;;;;;;;;;;
J4GX6P5U;S41;Assessing legacy software architecture with the autonomy ratio metric;journalArticle;2011;Dugerdil, Philippe;Software Engineering International Journal (SEIJ);;;;;Among the software quality metrics, coupling and cohesion play an important role since they provide a clue about the structuring of the classes of the system. They are, therefore, computed at the level of the classes. However, when analyzing the architecture of a system, we are not only interested in the class level, but also in the higher levels of the system structure, for example the packages and components. This is especially true when we need to assess the quality of this structuring on the viewpoint of system understanding. In this paper, we first present the motivation for the definition of two new coupling and cohesion metrics that are applicable to higher structuring levels than classes. We then present our main metric: the autonomy ratio that measures the “functional structuring” of a system that we believe is essential to system understanding. Although, traditionally, the coupling and cohesion metrics are computed based on static analysis (i.e. source code analysis to find the potential calls among the elements), we rely on dynamic analysis and present the way the metrics are computed. Finally, we present a case study of the assessment of a large industrial system based on our metrics and the findings we drew from this experiment. We conclude the paper with a discussion of the results and present the future work. The key contribution of the paper is the definition of the autonomy ratio metrics for software architecture assessment on the viewpoint of system understanding.;SQ1;;;;;;;;;;;;;
PVAHFPUD;S42;Evaluating security properties of architectures in unpredictable environments: A case for cloud;conferencePaper;2011;"Faniyi, Funmilade; Bahsoon, Rami; Evans, Andy; Kazman, Rick";;1-61284-399-9;;10.1109/WICSA.2011.25;https://ieeexplore.ieee.org/document/5959727;The continuous evolution and unpredictability underlying service-based systems leads to difficulties in making exact QoS claims about the dependability of architectures interfacing with them. Hence, there is a growing need for new methods to evaluate the dependability of architectures interfacing with such environments. This paper presents a method for evaluating the security quality attribute of architectures in service-based systems. The proposed method combines some properties of the Architectural Tradeoff Analysis Method (ATAM) and security testing using Implied Scenario. In particular, the scenario elicitation process of ATAM is improved by utilising Implied Scenario technique to generate scenarios which may be undetected using plain ATAM. An industrial case study of a problem related to securing data at the Software-as-a-Service layer on Force.com Cloud platform is adopted to validate the new method. The results indicate that our method found four additional security scenarios beyond the plain ATAM, resulting in four new risks and two new tradeoff points.;SQ1;;;;;;;;;;;;;
YNEX246D;S43;An Architecture Analysis Approach for Supporting Black-Box Software Development;conferencePaper;2011;"Admodisastro, Novia; Kotonya, Gerald";Software Architecture;978-3-642-23798-0;;10.1007/978-3-642-23798-0_17;;A typical component-based system architecture comprises a set of components that have been purposefully designed and structured to ensure that they have “pluggable” interfaces and an acceptable match with a defined system context. However, the black-box nature of many software components means there is never a clean match between system specifications and concrete software components. Systematic architecture analysis can provide an effective, rapid and relatively low-cost mechanism for addressing risks resulting from architectural adaptation and trade-offs. However, a review of current architecture analysis approaches reveals they differ widely with respect to their ability to support black-box software development. This paper describes an analysis approach that integrates the strengths of current approaches to provide a practical architecture analysis framework for black-box component-based development. The approach is illustrated using a real case study.;SQ1;;;;;;;;;;;;;
58ZDLMXK;S44;MORPHOSIS: A lightweight method facilitating sustainable software architectures;conferencePaper;2012;"Koziolek, Heiko; Domis, Dominik; Goldschmidt, Thomas; Vorst, Philipp; Weiss, Roland J";;1-4673-2809-X;;10.1109/WICSA-ECSA.212.40;https://ieeexplore.ieee.org/document/6337730;Managing the cost-effective evolution of industrial software systems is a challenging task because of their complexity and long lifetimes. Limited pro-active evolution planning and software architecture erosion often lead to huge maintenance costs in such systems. However, formerly researched approaches for evolution scenario analysis and architecture enforcement are only reluctantly applied by practitioners due to their perceived overhead and high costs. We have applied several recent sustainability evaluation and improvement approaches in a case study to the software architecture of a large industrial software system currently under development at ABB. We combined our selection of approaches in a lightweight method called MORPHOSIS, for which this paper presents experiences and lessons learned. We found that reasonable sustainability evaluation and improvement is possible already with limited efforts.;SQ1;;;;;;;;;;;;;
QK55HWH4;S45;Software architecture evolution through evolvability analysis;journalArticle;2012;"Breivold, Hongyu Pei; Crnkovic, Ivica; Larsson, Magnus";Journal of Systems and Software;;0164-1212;10.1016/j.jss.2012.05.085;https://www.sciencedirect.com/science/article/pii/S016412121200163X;"Software evolvability is a multifaceted quality attribute that describes a software system's ability to easily accommodate future changes. It is a fundamental characteristic for the efficient implementation of strategic decisions, and the increasing economic value of software. For long life systems, there is a need to address evolvability explicitly during the entire software lifecycle in order to prolong the productive lifetime of software systems. However, designing and evolving software architectures are the challenging task. To improve the ability to understand and systematically analyze the evolution of software system architectures, in this paper, we describe software architecture evolution characterization, and propose an architecture evolvability analysis process that provides replicable techniques for performing activities to aim at understanding and supporting software architecture evolution. The activities are embedded in: (i) the application of a software evolvability model; (ii) a structured qualitative method for analyzing evolvability at the architectural level; and (iii) a quantitative evolvability analysis method with explicit and quantitative treatment of stakeholders’ evolvability concerns and the impact of potential architectural solutions on evolvability. The qualitative and quantitative assessments manifested in the evolvability analysis process have been applied in two large-scale industrial software systems at ABB and Ericsson, with experiences and reflections described.";SQ1;;;;;;;;;;;;;
M9PH58PH;S46;An Approach towards Enterprise Architecture Analysis using AHP and Fuzzy AHP;journalArticle;2012;"Razavi, Mahsa; Sheikhvand, K.";International Journal of Machine Learning and Computing;;;10.7763/IJMLC.2012.V2.88;;Enterprise Architecture (EA) as a discipline that manages large amount of models and information about different aspects of the enterprise can support decision making on enterprise-wide issues. In order to provide such support, EA information should be amenable to analysis of various utilities and quality attributes. In this regard, this paper provides an approach based on Fuzzy Analytical Hierarchy Process (AHP) towards EA analysis. It proposes an extended quantitative method of assessing quality attribute achievement of different scenarios using AHP and Fuzzy AHP based on the knowledge and experience of EA experts and domain experts. Due to the uncertainty in the judgments of participants, the crisp pair-wise comparison in the conventional AHP is insufficient and imprecise to capture the right judgments. Therefore, a fuzzy logic is introduced in the pair-wise comparison of AHP in one of steps of the method. The applicability of the proposed approach is demonstrated using a practical case study.;SQ1;;;;;;;;;;;;;
8GQMH3XB;S47;On quick comprehension and assessment of software;conferencePaper;2013;"Bartoszuk, Cezary; Dąbrowski, Robert; Stencel, Krzysztof; Timoszuk, Grzegorz";;;;;https://doi.org/10.1145/2516775.2516806;"By an architecture of a software system we mean the fundamental organization of the system embodied in its components, their relationships to one another and to the system’s environment. It also encompasses principles governing the system’s design and evolution. Architectures of complex systems are obviously complex as well. The goal of our research is to harness this complexity. In this paper we focus on providing software architects with ability to quickly comprehend the complexity and assess the quality of software. The essential tools we use are: (1) a graph-based repository for collecting information on software artefacts, accompanied by (2) tools to perform software intelligence tasks, like analyzing dependencies among those artefacts, calculating their importance, and quality. On top of those tools we implement visualization methods that render the relative importance using size and the quality using colours. By means of such methods a software architect can at glance comprehend and assess the software, He/she can (1) find the starting points to dig into a complex system; (2) judge the cohesion and coupling of system components; and (3) assess the overall quality. We demonstrate this method using selected open-source projects of various sizes and qualities.";SQ1;;;;;;;;;;;;;
XGFYI6RZ;S48;On the Need of a Methodological Approach for the Assessment of Software Architectures within ISO26262;conferencePaper;2013;"Bonfiglio, Valentina; Montecchi, Leonardo; Rossi, Francesco; Bondavalli, Andrea";;;;;https://hal.archives-ouvertes.fr/hal-00848469;Safety analysis is becoming more and more important in a wide class of systems. In the automotive field, the recent ISO26262 foresees safety analysis to be performed at different levels: system, software and hardware. The assessment of architecture with respect to safety is typically better understood at system and HW levels, while an equivalent analysis at SW level has not such an established background. In literature, approaches exist to handle specific activities related to the safety assessment of software, but they are typically not so well integrated within a more general assessment and certification process. Recent safety standards put more and more emphasis on software-level safety analysis, therefore calling for a precise methodology for the assessment of software architectures. While ISO26262 requirements prescribe safety analysis of the software architecture, clear guidelines on how it should be performed are not provided, thus leaving an important gap for its industrial adoption. In this paper we provide our view on how such analysis should be performed, through the identification of a set of well defined and repeatable activities, thus providing our contribution to a timely problem of great relevance in the automotive domain.;SQ1;;;;;;;;;;;;;
WDT9Q8PH;S49;Early performance assessment in component-based software systems;journalArticle;2013;"Karimpour, Jaber; Isazadeh, Ayaz; Izadkhah, Habib";IET Software;;1751-8814;10.1049/iet-sen.2011.0143;https://digital-library.theiet.org/content/journals/10.1049/iet-sen.2011.0143;"Most techniques used to assess the qualitative characteristics of software are done in testing phase of software development. Assessment of performance in the early software development process is particularly important to risk management. Software architecture, as the first product, plays an important role in the development of the complex software systems. Using software architecture, quality attributes (such as performance, reliability and security) can be evaluated at the early stages of the software development. In this study, the authors present a framework for taking the advantages of architectural description to evaluate software performance. To do so, the authors describe static structure and architectural behaviour of a software system as the sequence diagram and the component diagram of the Unified Modelling Language (UML), respectively; then, the described model is automatically converted into the ‘interface automata’, which provides the formal foundation for the evaluation. Finally, the evaluation of architectural performance is performed using ‘queuing theory’. The proposed framework can help the software architect to choose an appropriate architecture in terms of quality or remind him/her of making necessary changes in the selected architecture. The main difference among the proposed method and other methods is that the proposed method benefits the informal description methods, such as UML, to describe the architecture of software systems; it also enjoys a formal and lightweight language, called ‘interface automata’ to provide the infrastructure for verification and evaluation.";SQ1;;;;;;;;;;;;;
9ISZRHN2;S50;Enterprise Information Systems Architecture—Analysis and Evaluation;journalArticle;2013;"Niu, Nan; Xu, Li Da; Bi, Zhuming";IEEE Transactions on Industrial Informatics;;1941-0050;10.1109/TII.2013.2238948;;Numerous software architecture proposals are available to industrial information engineers in developing their enterprise information systems. While those proposals and corresponding methodologies are helpful to engineers in determining appropriate architecture, the systematic methods for the evaluation of software architecture are scarce. To select appropriate software architecture from various alternatives appropriately, a scenario-based method has been proposed to assess how software architecture affects the fulfillment of business requirements. The empirical evaluation on the selection of a supply chain software tool has shown that the developed method offers remarkable insights of software development and can be incorporated into the industrial informatics practice of an organization with a moderate cost.;SQ1;;;;;;;;;;;;;
T4MIETGD;S51;Scenario-driven architecture assessment methodology for large data analysis systems;conferencePaper;2013;"Begoli, Edmon; Chila, Theodore F.; Inmon, William H.";2013 IEEE International Systems Conference (SysCon);;;10.1109/SysCon.2013.6549857;;The methodology we present in this paper emerged as a result of the technical and organizational assessment we conducted for a large data analytic system and for its expansion to support a significant new mission in healthcare domain. We developed a 4+1 dimensional approach for examining the different characteristics of a system with four traditional dimensions and a fifth, scenarios-based, dimension, introduced as an exploration device of the entire system in its business context. We present the principles, guidelines, and structure of the methodology as well as the results of the application of this process leading to a credible evaluation that better assesses current large data analysis systems than the previous, purely static assessment.;SQ1;;;;;;;;;;;;;
A8VPS3UH;S52;A Formal Method for Evaluation of a Modeled System Architecture;journalArticle;2013;"Rodano, Matthew; Giammarco, Kristin";Procedia Computer Science;;;10.1016/j.procs.2013.09.263;;Modeling is a powerful way to represent the desired organization and performance of a particular system and how it will meet the desired system objectives. There is a multitude of modeling methods, but determining whether the completed model effectively represents the desired system organization can be a challenge. System engineers can inspect the modeled system architecture to determine whether it is acceptable, but few formal methods exist to aid in the performance of this task. In practice, engineers apply heuristics and their experience to identify the characteristics of a “good” architecture. By formalizing these characteristics using logical notation, the quality attributes that constitute a “good” system architecture can be quantified and applied to determine the quality of an architectural model. Because these attributes are defined using a general notation, they can be instantiated using many system architecture tools and can be adapted to meet the needs of a specific architectural framework or particular project.;SQ1;;;;;;;;;;;;;
Q5RKFZMI;S53;Towards quantitative metrics for architecture models;conferencePaper;2014;"Sehestedt, Stephan; Cheng, Chih-Hong; Bouwers, Eric";Proceedings of the WICSA 2014 Companion Volume;978-1-4503-2523-3;;10.1145/2578128.2578226;https://doi.org/10.1145/2578128.2578226;Software architectures and their representations in models are instrumental in achieving sustainability and the fulfillment of requirements. In this context, sustainability encompasses cost efficient maintainability and evolvability, which are central concerns for long living software systems. Hence, it is of great importance to support an architect in addressing these concerns when designing and evolving architectures. However, there is no framework available in which a designed architecture can be evaluated against these important quality attributes. In this paper, we address this challenge by proposing seven metrics which characterize the completeness, consistency, correctness and clarity of the documentation. These seven metrics should enable an architect to efficiently identify issues in an architecture model.;SQ1;;;;;;;;;;;;;
ALBYH9E5;S54;Software with service oriented architecture quality assessment;conferencePaper;2014;"Nuraini, Aminah; Widyani, Yani";2014 International Conference on Data and Software Engineering (ICODSE);;;10.1109/ICODSE.2014.7062707;;Service Oriented Architecture (SOA) is becoming popular since its flexibility fulfill the need of rapidly changing enterprise requirement. Therefore, expectation of a good quality software with SOA is getting higher. To address this need, this paper presents a guideline to conduct quality assessment using an existing tool. The quality assessment model is designed by selecting the relevant quality factors, choosing an appropriate quality to metric mapping method, identifying the relevant metrics, and mapping each quality factor to the metrics. Using the model, the quality assessment process is prepared by identifying data and selecting the appropriate tools. The chosen tool may require some modification. The proposed quality assessment guideline can help the software quality assurance team to assess quality of their software with SOA. The proposed guideline has been used to assess the quality of an existing sofware with SOA (Bonita BPM). The result is considered as promising, although several improvement are still needed.;SQ1;;;;;;;;;;;;;
ESPG69K6;S55;Model-based energy efficiency analysis of software architectures;conferencePaper;2015;"Stier, Christian; Koziolek, Anne; Groenda, Henning; Reussner, Ralf";;;;10.1007/978-3-319-23727-5_18;https://link.springer.com/chapter/10.1007/978-3-319-23727-5_18;Design-time quality analysis of software architectures evaluates the impact of design decisions in quality dimensions such as performance. Architectural design decisions decisively impact the energy efficiency (EE) of software systems. Low EE not only results in higher operational cost due to power consumption. It indirectly necessitates additional capacity in the power distribution infrastructure of the target deployment environment. Methodologies that analyze EE of software systems are yet to reach an abstraction suited for architecture-level reasoning. This paper outlines a model-based approach for evaluating the EE of software architectures. First, we present a model that describes the central power consumption characteristics of a software system. We couple the model with an existing model-based performance prediction approach to evaluate the consumption characteristics of a software architecture in varying usage contexts. Several experiments show the accuracy of our architecture-level consumption predictions. Energy consumption predictions reach an error of less than 5.5% for stable and 3.7% for varying workloads. Finally, we present a round-trip design scenario that illustrates how the explicit consideration of EE supports software architects in making informed trade-off decisions between performance and EE.;SQ1;;;;;;;;;;;;;
EZ4H67TL;S56;An empirical evaluation model for software architecture maintainability for object oriented design;conferencePaper;2016;"Dayanandan, Udaya; Vivekanandan, K";;;;;https://dl.acm.org/doi/10.1145/2980258.2980459;The success of any software depends on the achievement of the quality requirements of the system. For this reason, the evaluation of software architecture to meet its quality demands is necessary. With regard to a set of desired quality attribute, Maintainability is considered as an important software attribute that plays a major role in quality level. The direct measurement of this quality is difficult because there is no standard method to measure quality factors. Many researchers have been still going on in relating quality analysis that attempts to measure quality in terms of attributes, design properties and metrics. In this work we have proposed a measurement model expressed in terms of mathematical formulas by taking ideas from the existing models. With a new set of metrics associated with the external and internal quality attributes, weights are defined and evaluated. According to ISO 25010, Maintainability and its sub-characteristics, Modularity, Reusability, Analyzability, Modifiability and Testability are evaluated using the proposed metrics. The designed model is to be validated using a case study.;SQ1;;;;;;;;;;;;;
A6ZFYKNG;S57;Statistical model checking of dynamic software architectures;conferencePaper;2016;"Cavalcante, Everton; Quilbeuf, Jean; Traonouez, Louis-Marie; Oquendo, Flavio; Batista, Thais; Legay, Axel";European Conference on Software Architecture;;;;;;SQ1;;;;;;;;;;;;;
6D54UG6B;S58;SPARTA: Security & Privacy Architecture Through Risk-Driven Threat Assessment;conferencePaper;2018;"Sion, Laurens; Van Landuyt, Dimitri; Yskout, Koen; Joosen, Wouter";2018 IEEE International Conference on Software Architecture Companion (ICSA-C);;;10.1109/ICSA-C.2018.00032;;The development of secure and privacy-preserving software systems entails the continuous consideration of the security and privacy aspects of the system under development. While contemporary software development practices do support such a continuous approach towards software development, existing threat modeling activities are commonly executed as single-shot efforts leading to a single, historic, and quickly obsolete view on the security and privacy of the system. This disconnect leads to undetected new issues and wasted efforts on already resolved problems, effectively accruing technical debt. The presented SPARTA prototype facilitates the consideration of security and privacy by providing support for: (i) capturing security and privacy design decisions in a DFD-based architectural abstraction, (ii) continuous threat elicitation on this knowledge-enriched abstraction, and (iii) risk analysis of the elicited threats for prioritizing security and privacy efforts. By capturing and continuously assessing the impact of security and privacy design decisions on the elicited threats, the progress towards securing the system can be assessed and alternatives can be compared, taking into account past and present design decisions.;SQ1;;;;;;;;;;;;;
TK9RIGG6;S59;Software Architectural Quality Assessment Model for Security Analysis Using Fuzzy Analytical Hierarchy Process (FAHP) Method;journalArticle;2018;"Dayanandan, Udaya; Kalimuthu, Vivekanandan";3D Research;;;10.1007/s13319-018-0183-x;https://ui.adsabs.harvard.edu/abs/2018TDR.....9..183D;In the last decade, the greater need for quality software led to the development of quality assessment especially at the software architecture (SA) level. Since software security is an important quality attribute, several models have been evolved to validate the security related issues at the SA level. This paper proposes a Fuzzy Analytical Hierarchy Process (FAHP) with Buckley method for security assessment at the SA level for object-oriented design. FAHP is a Multi-Criteria Decision Making approach which employs linguistic variables as a pair-wise comparison matrix to derive priorities of various selection attributes and sub-attributes. In addition, the proposed work uses genetic algorithm to fill the missing values in the comparison matrix of FAHP. The validation of FAHP model takes place by the use of four versions of apache Tomcat series namely TC 7.0.6, TC 7.0.22, TC 7.0.39 and TC 7.0.47. The obtained results ensure that the proposed FAHP model with Buckley method performs well than existing methods in terms of security index to measure the performance at the SA level and defect density ratio to validate the results.;SQ1;;;;;;;;;;;;;
XIDWFILD;S60;Availability Assessment of Software Systems Architecture Using Formal Models;journalArticle;2018;"Sadeghian, Mahbubeh; Motameni, Homayun";International Journal of Computer Applications Technology and Research;;23198656;10.7753/IJCATR0705.1001;http://ijcat.com/archieve/volume7/issue5/ijcatr07051001.pdf;There has been a significant effort to analyze, design and implement the information systems to process the information and data, and solve various problems. On the one hand, complexity of the contemporary systems, and eye-catching increase in the variety and volume of information has led to great number of the components and elements, and more complex structure and organization of the information systems. On the other hand, it is necessary to develop the systems which meet all of the stakeholders' functional and non-functional requirements. Considering the fact that evaluation and assessment of the aforementioned requirements - prior to the design and implementation phases - will consume less time and reduce costs, the best time to measure the evaluable behavior of the system is when its software architecture is provided. One of the ways to evaluate the architecture of software is creation of an executable model of architecture.;SQ1;;;;;;;;;;;;;
UIK8VX4H;S61;A Fuzzy Analytical Hierarchy Process (FAHP) Based Software Quality Assessment Model: Maintainability Analysis;journalArticle;2018;"Dayanandan, Udaya; Kalimuthu, Vivekanandan";International Journal of Intelligent Engineering and Systems;;;10.22266/ijies2018.0831.09;;Software quality assessment at the architectural level is efficient because it provides various advantages to find and fix design errors at the earliest stage of software development life cycle (SDLC).Numerous methods have been evolved to validate quality-related issues at the architectural level. The software quality comprises of a total of eight attributes where maintainability is one of the important attribute which affects the overall system quality. Though few methods are available for maintainability analysis, none of the state of art method employs fuzzy logic with Quality Model for Object Oriented Design (QMOOD) metric suite. In this paper, the fuzzy analytic hierarchy process (FAHP) method is proposed with Buckley method to evaluate the influence of maintainability and its subattributes in software quality at the architectural level. The proposed evaluation model is tested against several versions of the MFC and OWL windows application frameworks and the obtained results are compared with the state-of-the-art methods. This experimental analysis shows that the FAHP with Buckley method is superior to the other compared methods.;SQ1;;;;;;;;;;;;;
72N9A55J;S62;Assessing migration of a 20-year-old system to a micro-service platform using ATAM;conferencePaper;2019;"Cruz, Pablo; Astudillo, Hernán; Hilliard, Rich; Collado, Miguel";;1-72811-876-X;;10.1109/ICSA-C.2019.00039;https://ieeexplore.ieee.org/abstract/document/8712154;Architecture evaluation is a systematic approach to evaluate target architectures and ATAM (Architectural Trade-off Analysis Method) is one of the available methods. Migration of software systems imply many architectural decisions that should be systematically evaluated to assess concrete trade-offs and risks. This article reports on the ATAM usage at a mid-size Chilean specialty software development company to assess the migration of its 20-year old flagship product to a micro-service platform. Over three days, 10 key architectural decisions, addressing 35 scenarios, were considered. Since almost all requirements were deemed essential for legal reasons, the evaluation scheme used a modified importance dimension distinguishing among business-key (first line deal breakers), legally-mandated (second-line deal breakers), and desirable requirements. Key lessons learned include the very positive client feedback on the introduction of systematic evaluation of architectural choices using business criteria.;SQ1;;;;;;;;;;;;;
YYX4Y38F;S63;Early reliability assessment of component-based software system using colored petri net;journalArticle;2019;"Hosseinzadeh-Mokarram, Amir; Isazadeh, Ayaz; Izadkhah, Habib";Turkish Journal of Electrical Engineering and Computer Sciences;;1300-0632;10.3906/elk-1805-82;http://search/yayin/detay/337189;Assessment of reliability in the early stages of software development from architectural models is one ofthe major challenges that many studies have addressed in this field in the last decade. The main drawbacks of existingmethods are the following: 1) considering equal impact for all parts of the software architecture on system reliability,and 2) inability to determine the contribution of each part of the software in the system failure. This paper introducesthe extended version of the colored petri net as an underlying verifiable model to evaluate the reliability of a softwaresystem. The proposed model enhances reliability assessment of the software system by measuring the density of failure foreach part of the software system, predicting the reliability during execution of a scenario, and estimating the reliabilityof every structural part of a program, such as loops and conditions. These innovations enable software architects tocost-effectively identify and correct the vulnerable parts of a system in the early stages of software development. Thehigh-level model of the scenario is taken as a UML sequence diagram. Synthesis of the formal model is conducted usingan introduced graph called a fragments dependency graph. The practicality of the suggested approach is illustrated bya case study.;SQ1;;;;;;;;;;;;;
3IZVDV6F;S64;Quick Evaluation of a Software Architecture Using the Decision-Centric Architecture Review Method: An Experience Report;conferencePaper;2020;"Cruz, Pablo; Salinas, Luis; Astudillo, Hernán";;;;;https://link.springer.com/chapter/10.1007/978-3-030-58923-3_19;Software architecture evaluations allow systematic checking of software architecture fitness regarding the context and business. However, selecting and using an evaluation method always have some challenges and issues. This article reports an architecture review while developing an innovation projects support platform for a Chilean R&D and engineering institution. We chose DCAR (Decision-Centric Architecture Review) because it has lightweight requirements on documentation and resources, it can evaluate a project already running, and it did not impact a schedule where architecture reviews had not been considered from the start. We describe the review of three accepted and one rejected decisions. Lessons learned and benefits observed include recording decisions’ rationale, visibilization of some technological issues, and rethinking of some previously made architectural decisions. Finally, we recommend making frequent mini-reviews of architecture decisions, to understand the architecture, formalize it with its resulting reports, and raise its visibility in the team itself.;SQ1;;;;;;;;;;;;;
WUUP3E4H;S67;Modeling and simulation of software architecture in discrete event system specification for quality evaluation;journalArticle;2014;"Bogado, Verónica; Gonnet, Silvio; Leone, Horacio";SIMULATION;;0037-5497;10.1177/0037549713518586;https://doi.org/10.1177/0037549713518586;Software quality is an important issue in software engineering. The evaluation of software architecture is crucial to achieve quality scenarios, which reduces development and maintenance costs. This work presents a discrete event simulation environment for the software architecture assessment considering both functional and quality aspects. Discrete event system specification (DEVS) formalism and the underlying framework are used to specify the simulation elements. DEVS is based on the system theory and follows the engineering and object-oriented fundamentals to construct complex dynamic systems. The proposed environment is built in a modular and hierarchical way that provides scalability and reusability advantages. Although the proposal is focused on three quality attributes and a few metrics, this approach enables the definition of new elements and metrics related to other quality attributes that can be visible at runtime. A traditional architecture illustrates the proposal, where preliminary computational experiments for this real software system and concrete quality scenarios demonstrate the feasibility of the integrated simulation environment for the software architecture evaluation. In addition, a discussion shows how the results could help architects make design decisions to improve software quality during development.;SQ1;;;;;;;;;;;;;
6BSTZECJ;S68;A Fuzzy AHP Based Approach Towards Enterprise Architecture Evaluation;journalArticle;2009;"Razavi, Mahsa; Aliee, Fereidoon Shams; Sarabadani, Amir Esmaeil";;;;;;Enterprise Architecture (EA) as a discipline with numerous and enterprise-wide models, has pervasive impact across the enterprise. Due to expensive implementation of enterprise-wide scenarios, it is critical to perform an architecture assessment before any decision about choosing a scenario. In order to provide such support, EA models should be amenable to analysis of various utilities and quality attributes. This paper provides an approach based on Fuzzy Analytical Hierarchy Process towards EA analysis. It proposes a quantitative method of measuring quality attribute achievement of different scenarios using AHP based on the knowledge and experience of EA experts and domain experts. Due to the vagueness and uncertainty in the judgments of participants, the crisp pair wise comparison in the conventional AHP is insufficient and imprecise to capture the right judgments. Therefore, a fuzzy logic is introduced in the pairwise comparison of AHP to make up for this deficiency. In this method, the situation of the enterprise is considered in giving weight to the different criteria and sub criteria of each quality attribute. The applicability of the proposed approach is demonstrated using a practical case study.;SQ1;;;;;;;;;;;;;
V3NLQLQA;S69;SAAM: a method for analyzing the properties of software architectures;conferencePaper;1994;"Kazman, R.; Bass, L.; Abowd, G.; Webb, M.";Proceedings of 16th International Conference on Software Engineering;;;10.1109/ICSE.1994.296768;;While software architecture has become an increasingly important research topic in recent years, insufficient attention has been paid to methods for evaluation of these architectures. Evaluating architectures is difficult for two main reasons. First, there is no common language used to describe different architectures. Second, there is no clear way of understanding an architecture with respect to an organization's life cycle concerns -software quality concerns such as maintainability portability, modularity, reusability, and so forth. We address these shortcomings by describing three perspectives by which we can understand the description of a software architecture and then proposing a five-step method for analyzing software architectures called SAAM (Software Architecture Analysis Method). We illustrate the method by analyzing three separate user interface architectures with respect to the quality of modifiability.<>;SQ1;;;;;;;;;;;;;
8TEKKBL4;S70;Lightweight evaluation of software architecture decisions;bookSection;2014;"Eloranta, Veli-Pekka; van Heesch, Uwe; Avgeriou, Paris; Harrison, Neil; Koskimies, Kai";Relating System Quality and Software Architecture;978-0-12-417009-4;;;https://www.sciencedirect.com/science/article/pii/B9780124170094000065;Software architecture is an important foundation of every software project. Therefore, it is advisable to evaluate it in early stages of the software design. Architecture evaluation helps to uncover risks and suboptimal decisions before they cause tremendous cost and re-engineering efforts. Unfortunately, many software companies still do not integrate architecture evaluations into their software projects as a standard activity. This is partially because architecture evaluation is perceived as complicated and time-consuming by some people. Modern agile development methodologies are perceived as avoiding up-front architectural design, which amplifies this problem. In this chapter, we present an extended description of the decision-centric architecture review (DCAR) method. DCAR is lightweight and easy to integrate into different types of software projects (traditional and agile projects). We present the method in detail and show how it can be used in an incremental development process. Additionally, we explain different approaches for integrating DCAR with Scrum to support continuous and iterative architecture evaluation. Finally, we present industrial experiences from the evaluations we carried out using DCAR, both as external reviewers in industrial projects and when applying DCAR in our own industrial software projects.;SQ1;;;;;;;;;;;;;
9JENKWYC;S71;Enterprise Architecture Modifiability Analysis;bookSection;2018;"Busch, Norbert Rudolf; Zalewski, Andrzej";Towards a Synergistic Combination of Research and Practice in Software Engineering;978-3-319-65208-5;;;https://doi.org/10.1007/978-3-319-65208-5_9;As changes to organisations and the systems supporting them are getting ever more rapid, the modifiability of evaluation architecture is becoming ever more important. This paper presents a proposal of a scenario-based method for evaluating the modifiability of enterprise architectures. The method has been developed as an adaptation of the Software Architecture Analysis Method (SAAM) onto the field of enterprise architecture. It assumes that such architecture should be represented as a set of models in the ArchiMate language. The proposed method delivers an architecture assessment process together with techniques supporting the architecture assessment, such as representing requirements as scenarios of probable changes, analysing the impact of the changes represented by scenarios on enterprise architecture. The method has been validated on a real world example of an Enterprise Architecture of a Social Policy Support Entity of a certain municipality.;SQ1;;;;;;;;;;;;;
XB8HUXH2;S65;Sustainability Debt: A Portfolio-Based Approach for Evaluating Sustainability Requirements in Architectures;conferencePaper;2016;"Ojameruaye, Bendra; Bahsoon, Rami; Duboc, Leticia";2016 IEEE/ACM 38th International Conference on Software Engineering Companion (ICSE-C);;;;;"Architectural Sustainability refers to the ability of an architecture to achieve its goals while sustaining its value on dimensions related to environmental, social, economic, individual and/or technical during its operation and evolution. While the process of architectural design implies a fit between the requirements, system conditions and constraints; incomplete information and uncertainty may increase the cost of the architecture, introduce risks, alter its value and influence the extent to which it can evolve and sustain. We propose an economics-driven architectural evaluation method which extends the Cost Benefits Analysis Method (CBAM) and integrates principles of modern portfolio theory to control the risks when linking sustainability concern to architectural design decisions. The method aims at identifying portfolio(s) of architecture design decisions which are more promising for adding/delivering value while reducing risk on the sustainability dimensions. The method quantifies the sustainability debt of these decisions. The ultimate goal is to develop an objective decision-support framework for reasoning about sustainability requirements in relation architecture decisions in the presence of uncertainty. We evaluate the approach with an Emergency Deployment System (EDS). The results show that the method can make the value, cost and risks of architectural design decisions and sustainability requirements explicit.";SQ2;;;;;;;;;;;;;
V6L4G8CA;S66;An Action Research for Improving the Sustainability Assessment Framework Instruments;journalArticle;2020;"Condori-Fernandez, Nelly; Lago, Patricia; Luaces, Miguel R.; Places, Ángeles S.";Sustainability;;2071-1050;10.3390/su12041682;https://www.mdpi.com/2071-1050/12/4/1682;In the last years, software engineering researchers have defined sustainability as a quality requirement of software, but not enough effort has been devoted to develop new methods/techniques to support the analysis and assessment of software sustainability. In this study, we present the Sustainability Assessment Framework (SAF) that consists of two instruments: the software sustainability–quality model, and the architectural decision map. Then, we use participatory and technical action research in close collaboration with the software industry to validate the SAF regarding its applicability in specific cases. The unit of analysis of our study is a family of software products (Geographic Information System- and Mobile-based Workforce Management Systems) that aim to address sustainability goals (e.g., efficient collection of dead animals to mitigate social and environmental sustainability risks). The results show that the sustainability–quality model integrated with the architectural decision maps can be used to identify sustainability–quality requirements as design concerns because most of its quality attributes (QAs) have been either addressed in the software project or acknowledged as relevant (i.e., creating awareness on the relevance of the multidimensional sustainability nature of certain QAs). Moreover, the action–research method has been helpful to enrich the sustainability–quality model, by identifying missing QAs (e.g., regulation compliance, data privacy). Finally, the architectural decision maps have been found as useful to guide software architects/designers in their decision-making process.;SQ2;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;